---
title: 文法定義
date: 2021-01-16T10:57:29.049Z
weight: 1
description: mimium言語の文法定義に関する項目です。
draft: false
toc_hide: false
---
mimium言語の文法規則に関する項目です。

## コメントアウト

C++やJavaScriptと同様、行中の`//`より右側はコメントとして扱われます。
また`/*  */`のように囲むと、複数行をまとめてコメントアウトできます。

## 変数宣言

## 型

**型**とは変数などのデータを数値や文字列など目的に応じて区別するための概念です。
mimiumは**静的型付け**言語と呼ばれる、コンパイル時に（音を実際に鳴らす前）すべての型が決定される言語です。

静的型付け言語は一般的に、実行中に型をチェックする言語よりも実行速度の面で有利です。その一方、型の指定を手動で行う場合は記述が長くなりがちというデメリットも存在しますが、mimiumでは**型推論**と呼ばれる、文脈から型が自動的に決定できる場合は型注釈を省略できる機能が存在しているので、コードを簡潔に保つことが可能です。

型にはそれ以上分解できない最小単位であるプリミティブ型と、複数の型を組み合わせて作る合成型（aggregate type）が存在します。

型の明示的な注釈は変数の宣言と関数の宣言時に可能です。
変数および関数のパラメータでは名前に続けて`:`（コロン）を挟み型名を書くことで指定可能です。

```rust
myvar:float = 100
```
以下のように異なる型へ代入した場合はコンパイル時にエラーが発生します。
```rust
myvar:string = 100
```

関数での型宣言では返り値をパラメータの括弧に続けて`->`を挟んで書くことで指定できます。

```rust
fn add(x:float,y:float)->float{
  return x+y
}
```
このadd関数の場合、文脈からxとyがfloatであることを予測できる[^binaryop]ので以下のように省略できます。

```rust
fn add(x,y){
  return x+y
}
```

[^binaryop]: mimiumでは`+`や`*`などの算術演算子を数値型にしか使えないため。今後変更になる可能性もあります。
### プリミティブ型

mimiumにおけるプリミティブ型は`float`と`string`、`void`のみです。

mimiumでは数値型は`float`（内部的には64bit float）のみとなっています。
整数を利用するには`round`、`ceil`、`floor`関数などを利用します。

`string`型の値は`"hoge"`のようにダブルクオーテーションで囲った文字列リテラルから生成できます。
現在は文字列の切り出しや結合には対応しておらず、用途は基本的には

1. `printstr`関数に渡してデバッグ用途に使う
2. `loadwav`関数に渡してオーディオファイルを読み込む
3. `include`に渡して他のソースファイルを読み込む

のいずれかに限られています。

`void`は値を持たない型で、関数の返り値が存在しないことを明示するのに使用します。
### 合成型

#### 関数

mimiumでは関数が第一級の値として扱えます。これは、関数を変数に代入したり、関数のパラメータとして取ったりすることができるということです。詳しくは高階関数の項を参照。

たとえば、先ほどのadd関数の型注釈は`(float,float)->float`のようになっています。

add関数を型を明示して変数として格納する場合は以下のようになります。

```rust
fn add(x,y){
  return x+y
}
my_function:(float,float)->float = add
```

```bnf
type :  float
      | string
      | void
      | (type,type,...)->type
      | (type,type,...)
      | [type x n]
```

#### 配列

配列は、同じ型の値を複数個連続して格納できる型です。`[]`（アングルブラケット）で囲んだカンマ区切りの値で生成できます。

```rust
myarr = [1,2,3,4,5,6,7,8,9,10]
```

配列型の値に`myarr[0]`のようにアングルブラケットで0基準のインデックスを指定することで配列の値を取り出すことができます。

```
arr_content = myarr[0] //arr_content should be 1
```
また左辺値に同様にアングルブラケットを使うことで配列の中身を書き換えることができます。

```
myarr[4] = 20 //myarr becomes [1,2,3,4,20,6,7,8,9,10]
```

**配列のサイズは固定です。配列の後ろに値を追加していくような操作はできません。また境界チェックもないため範囲外へのアクセスはクラッシュを引き起こします。**
##### 自動内挿

インデックスは小数点以下の値でアクセスされた場合、自動で線形補完されて出力されます。

```
arr_content = myarr[1.5] //should be 2.5
```
自動で整数に丸められることはないので内挿を避けたい場合は`round`関数などでインデックスを丸める必要があります。

#### タプル

タプルは、異なる型を1つにまとめた値です。変数を`()`（丸括弧）で囲んでカンマ区切りの変数を入れることで生成できます。
タプルは配列とも似ていますが、各要素で異なる型を持つことができます。

```rust
mytup = (100,200,300)
```

左辺値にカンマ区切りの変数を置くことでタプルの値を取り出すことができます。この時には括弧で区切る必要がありません。
```rust
one,two,three = mytup
```

{{< alert color="warning">}}
*今後、左辺値で分解するだけではなく、`mytup.1`のようにインデックスで取り出す記法も実装される予定です。*
{{< /alert >}}

タプルはmimiumの中では典型的に信号処理でステレオやマルチチャンネルなどのオーディオ信号のチャンネルをまとめて扱うために利用されています。

## 関数

### 無名関数（ラムダ式）

実は先ほどの関数宣言は以下の構文へのエイリアスです。

```rust
add = |x:float,y:float|->float{return x+y} 
```
このような関数を変数に代入しないまま直接呼び出すことも可能です。

```rust
println(|x,y|{return x + y}(1,2)) //print "3"
```
またブロックの構文のところで解説しますが、ブロックの最後の1行はreturnの代わりに単に式を置くことで、returnの代わりにできます。
つまり、`add`関数は型推論も組み合わせると以下の例まで省略できます。

```rust
add = |x,y|{x+y}
```


### `|>` 演算子

mimiumではパイプ演算子`|>`利用することで`a(b(c(d)))`のようにネストした関数呼び出しを`d |> c |> b |> a`のように書き換えることができます。

{{< alert color="warning">}}
*現在パイプ演算子はパラメータが1つの関数でのみ使用可能です。今後パラメータパックなどの機能でタプル型の値を自動展開することでパラメータが2つ以上の関数でも利用できるようになる予定です.*
{{< /alert >}}

### 再帰によるループ

TBD
### self

TBD

### 変数のスコープ

mimiumはレキシカルスコープと呼ばれる言語で、関数の外側で定義されている変数を参照することが可能です。
TBD

## 条件分岐

TBD

## `@`演算子による遅延実行

TBD

## include

TBD

## BNFによる文法定義、演算子の優先順位など

TBD
