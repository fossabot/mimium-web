---
title: "Coding Style"
date: 2020-08-16
weight: 2
description: >
  C++のコーディング規約、方針について
---

## 基本的方針

- 言語仕様はC++17に準拠する。主な理由はstd::variantやstd::optionalを積極的に利用するため。
- 可読性かわずかな実行速度の向上で迷ったら可読性を取る。そもそもC++の時点である程度速いことが保証されているので多少は富豪的処理でも構わないし、その程度の迷いは大体最適化されるとほぼ同じになる。
- できるだけ外部ライブラリを用いない（とくにboostなど汎用的なものについては）。STLはなるべく積極的に活用する。
    - コンパイラにはパーサーでbison(yacc)とflex(lex)に依存している。これはとくにbisonのソースのドキュメントとしての価値があるため今後も利用していくつもりだが、flexに関してはUnicodeが読み込めないなどの問題があるためREflexなどに移行するか手動実装に切り替えるかもしれない。要検討。
    - ランタイムには現在オーディオファイル読み込みでlibsndfileなどに依存しているがこれは実行時にしか必要ないので後々プロジェクト構造として分離していきたい。

## 動的多相 (Dynamic Polymorphism)

C++に置いて型ごとに個別の処理内容を分ける **多相（ポリモーフィズム）** にはコンパイル時に型を確定させる静的多相と動的多相の2種類が存在する。静的多相は主にテンプレートによって実現され、動的多相は主に継承と仮想関数を用いて実現される。

しかしmimiumの開発では動的多相に仮想関数を一切使わない。代わりにC++17よりSTLに導入された`std::variant`を用いる。`std::variant<T1,T2,T3...>`はT1~Tnの複数種類のどれかの型を持つ変数を代入できる型であり、`std::get<T>`や`std::visit()`を用いることで動的に型に応じての処理を分けることが可能になる。これは関数型などでよく見られる **直和型** と呼ばれる型の代わりでもあり、`std::visit`はテンプレートやconstexprを用いた処理分けと組み合わせるといわゆるパターンマッチングに近いことが可能になる。内部実装的には取りうる型の最大値のメモリ分+現在どの型を保持しているのかのタグ（整数）を確保する形になっているので **Tagged Union**とも呼ばれます。

mimiumにおける具体的な型でいうと抽象構文木である`mimium::ast::Expr`や`mimium::ast::Statement`、中間表現である`mimium::mir::Instruction`、（mimium言語における）型を表す`mimium::types::Value`などが`std::variant`へのエイリアスです。

仮想関数よりも`variant`を用いるメリットはなんでしょうか？1つは、実行コストがかかることです。仮想関数は実行時に関数へのテーブルを保持し仮想関数が呼び出されるたびにそれを参照する必要があるため、`std::variant`を用いた多相の方が実行速度では一般的に有利だとされています。

もう1つはアップキャストの問題です。抽象構文木のような木構造のデータを渡りながら処理をする時、どうしても

- 継承した個別の型を基底クラスのポインターでダウンキャストして受け取る
- 仮想関数を用いて型に応じた処理をする
- 処理したあと帰ってきたポインターを元の型に戻し（**アップキャスト**）、さらに処理を続ける

といったパターンが発生します。このアップキャストは一般的なコーディングでは、間違った型へキャストして終えば予測不可能な挙動が起きるので御法度とされています。仮想関数で用いている実行時型情報（RTTI）を用いる`dynamic_cast`を使って動的に型検査をして安全にアップキャストする方法もありますが、記述が長くなりがちなども問題もあります。一方で`std:variant`を使用するとこのようなダウン→アップキャストの必要はないので型情報が明確に取り扱えます。

またこうした（複数の型）x（型に応じた処理を複数種類）と組み合わせる方法はビジターパターンとも呼ばれ、 `std::visit(function_object,variant_variable)`ではこの形が引数としてシンプルに表されています。一方仮想関数を使ってのビジターパターンはデータ側にacceptと呼ばれるメソッドを実装しておく必要があるので、データはデータ、関数は関数というように構造を分離することが難しくなります。

## 再帰的データ構造

`std::variant`にも難しい点はあります。そのうち重要な点は再帰的データ構造がそのままでは扱えないことです。

たとえば、`types::Value`は`types::Float`や`types::Function`など取りうる型すべてを含んでいますが、ここで`types::Function`のメンバ変数にはたとえば返り値を表す型として`types::Value`が含まれてしまっています。`std::variant`は通常の数値型のデータなどと同じように、取りうる型の最大値分だけメモリをスタック確保し、ヒープアロケーションは行わない仕様となっており、再帰的なデータ構造の場合はデータサイズを静的に決定できなくなってしまうのでコンパイルできなくなります。

これを回避するためには、再帰的な部分を持つデータについては実体の代わりにポインタを格納するなどの方法が考えられるのですが、初期化やメンバアクセスなどが統一されないためややこしくなるなどの問題があるため、mimiumでは次の記事を参考にしたヘルパークラスを利用しています。

[Breaking Circular Dependencies in Recursive Union Types With C++17 - Don’t Compute In Public(last view:2020-08-17)](https://medium.com/@dennis.luxen/breaking-circular-dependencies-in-recursive-union-types-with-c-17-the-curious-case-of-4ab00cfda10d)

記事中の`recursive_wrapper<T>`を、mimium内部では`Rec_Wrap<T>`と名付け、さらにこの型を`rT`（たとえば`Function`に対して`rFunction`といった形で）エイリアスしています。

具体的には内部の`T`の実体を要素数1の`std::vector<T>`に確保し、キャスト演算子として`T& ()`を実装しimplicitに元の型から構築、キャストして参照を受け取ることができるようにしています。`std::vector`は`T`の中身が不完全なままでもスタック上のデータサイズを確定させることができるのでコンパイルが通るようになるのです。

たとえば`std::visit`でパターンマッチングする時には以下のようにします。

```cpp

types::Value operator()(types::Function& f){
    return  someProcess(f);
}
/*~~~~~*/
template<typename T>
types::Value operator()(Rec_Wrap<T>& t){
    return  (*this)(static_cast<T&>(t));
}

```
`Rec_Wrap<T>`を一度キャストして剥がすテンプレート関数を使います。`operator()(Rec_Wrap<types::Function>& rf)`を直接オーバーロードしても構わないのですが、この`rf`は直接メンバアクスができないため一度ローカル変数で`types::Function&`にキャストしてやらないといけなかったりする二度手間が発生します。



## エラー処理、例外

`try`、`throw`、`catch`と言ったC++標準のエラー処理を積極的に利用する。`throw`を使ったエラー処理は実行コストが高いというデメリットがあるが、正常系で処理をしている間はコストがかからず、言語組み込みの仕様なのでエラー処理部の可読性が高い。

optionalなどを活用したエラー処理クラスの実装は型シグネチャが複雑になり可読性が下がるなどのデメリットもある。内部的に使用しているLLVMのライブラリでは実行速度を重視して`Expected`クラスなどでこの形式でエラー処理をしているため、こちらと`try`、`catch`のエラー処理を混ぜるのはあまり効率がよくはない、混乱するといった問題点もある。

ただし、現状ではコンパイラもランタイムもtry/catchのエラー処理を使用しているが、ランタイム側では実行時間にセンシティブである、今後組み込み向けなどに移植される可能性もあると言った事情を考えるとoptional等を活用した処理に変更すべきかもしれない。要検討。

基本的に`try`,`catch`はコンパイラでの処理のはじめに行い深くネストすることはしない。どの道、ほとんどのケースでエラーが起きれば最終的にコンパイルエラーの形に帰着するため。必要に応じてエラークラスを継承して種類分けし、catchしたところでまとめてエラーの型ごとにメッセージ等を個別に処理する。( **エラークラスの定義は今後の課題**)